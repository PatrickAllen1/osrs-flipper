# Monte Carlo Price Simulation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add Monte Carlo price simulations to predict probability of profit/loss for individual items and optimize portfolio allocation across multiple items.

**Architecture:** Create a `simulator.py` module with a `PriceSimulator` class that uses bootstrap resampling of historical daily returns to generate future price paths. Add `deep` CLI command for single-item analysis and enhance `portfolio` command with `--optimize` flag to run sims on all candidates and find optimal allocation.

**Tech Stack:** Python stdlib (random, statistics), numpy for vectorized operations, existing OSRSClient for data

---

## Task 1: Daily Returns Calculator

**Files:**
- Create: `osrs_flipper/simulator.py`
- Test: `tests/test_simulator.py`

**Step 1: Write the failing test**

Create `tests/test_simulator.py`:

```python
"""Tests for Monte Carlo price simulation."""
import pytest
from osrs_flipper.simulator import calculate_daily_returns


def test_calculate_daily_returns_basic():
    """Daily returns should be percentage changes between consecutive prices."""
    prices = [100, 110, 105, 115]  # +10%, -4.5%, +9.5%
    returns = calculate_daily_returns(prices)

    assert len(returns) == 3
    assert abs(returns[0] - 0.10) < 0.001  # 10% gain
    assert abs(returns[1] - (-0.0455)) < 0.001  # 4.55% loss
    assert abs(returns[2] - 0.0952) < 0.001  # 9.52% gain


def test_calculate_daily_returns_insufficient_data():
    """Should return empty list if fewer than 2 prices."""
    assert calculate_daily_returns([100]) == []
    assert calculate_daily_returns([]) == []
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_simulator.py::test_calculate_daily_returns_basic -v`
Expected: FAIL with "ModuleNotFoundError: No module named 'osrs_flipper.simulator'"

**Step 3: Write minimal implementation**

Create `osrs_flipper/simulator.py`:

```python
"""Monte Carlo price simulation for flip opportunities."""
from typing import List


def calculate_daily_returns(prices: List[int]) -> List[float]:
    """Calculate daily percentage returns from price series.

    Args:
        prices: List of historical prices (oldest first).

    Returns:
        List of daily returns as decimals (0.10 = 10% gain).
    """
    if len(prices) < 2:
        return []

    returns = []
    for i in range(1, len(prices)):
        if prices[i - 1] > 0:
            daily_return = (prices[i] - prices[i - 1]) / prices[i - 1]
            returns.append(daily_return)

    return returns
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_simulator.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/simulator.py tests/test_simulator.py
git commit -m "feat(simulator): add daily returns calculator"
```

---

## Task 2: Bootstrap Price Path Generator

**Files:**
- Modify: `osrs_flipper/simulator.py`
- Modify: `tests/test_simulator.py`

**Step 1: Write the failing test**

Add to `tests/test_simulator.py`:

```python
import random

def test_generate_price_path_length():
    """Generated path should have correct number of days."""
    random.seed(42)
    returns = [0.01, -0.02, 0.03, -0.01, 0.02]
    start_price = 1000

    from osrs_flipper.simulator import generate_price_path
    path = generate_price_path(start_price, returns, days=10)

    assert len(path) == 11  # start + 10 days
    assert path[0] == start_price


def test_generate_price_path_uses_bootstrap():
    """Path should be generated by resampling from historical returns."""
    random.seed(42)
    # All positive returns - price should generally increase
    returns = [0.05, 0.03, 0.04, 0.02, 0.06]
    start_price = 1000

    from osrs_flipper.simulator import generate_price_path
    path = generate_price_path(start_price, returns, days=30)

    # With all positive returns, final price should be higher
    assert path[-1] > start_price
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_simulator.py::test_generate_price_path_length -v`
Expected: FAIL with "cannot import name 'generate_price_path'"

**Step 3: Write minimal implementation**

Add to `osrs_flipper/simulator.py`:

```python
import random


def generate_price_path(
    start_price: int,
    historical_returns: List[float],
    days: int,
) -> List[int]:
    """Generate a simulated price path using bootstrap resampling.

    Args:
        start_price: Starting price.
        historical_returns: List of historical daily returns to sample from.
        days: Number of days to simulate.

    Returns:
        List of prices including start_price (length = days + 1).
    """
    if not historical_returns:
        return [start_price] * (days + 1)

    path = [start_price]
    current_price = float(start_price)

    for _ in range(days):
        # Bootstrap: randomly sample a historical return
        daily_return = random.choice(historical_returns)
        current_price = current_price * (1 + daily_return)
        path.append(int(round(current_price)))

    return path
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_simulator.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/simulator.py tests/test_simulator.py
git commit -m "feat(simulator): add bootstrap price path generator"
```

---

## Task 3: Monte Carlo Simulation Runner

**Files:**
- Modify: `osrs_flipper/simulator.py`
- Modify: `tests/test_simulator.py`

**Step 1: Write the failing test**

Add to `tests/test_simulator.py`:

```python
def test_run_simulation_returns_distribution():
    """Simulation should return price distribution statistics."""
    random.seed(42)
    prices = [1000, 1010, 990, 1020, 980, 1030, 970, 1040]

    from osrs_flipper.simulator import PriceSimulator

    sim = PriceSimulator(prices)
    result = sim.run(num_sims=1000, days=30)

    assert "prob_profit" in result
    assert "prob_loss" in result
    assert 0 <= result["prob_profit"] <= 1
    assert 0 <= result["prob_loss"] <= 1
    assert abs(result["prob_profit"] + result["prob_loss"] - 1.0) < 0.01

    assert "percentiles" in result
    assert 5 in result["percentiles"]
    assert 25 in result["percentiles"]
    assert 50 in result["percentiles"]
    assert 75 in result["percentiles"]
    assert 95 in result["percentiles"]


def test_run_simulation_with_mean_reversion():
    """Oversold items should have mean reversion boost."""
    random.seed(42)
    # Price crashed from 1000 to 500 (50th percentile = 0%)
    prices = [1000, 900, 800, 700, 600, 500]
    current_price = 500

    from osrs_flipper.simulator import PriceSimulator

    sim = PriceSimulator(prices, mean_reversion_strength=0.02)
    result = sim.run(num_sims=1000, days=30, start_price=current_price)

    # With mean reversion, should have >50% chance of profit
    assert result["prob_profit"] > 0.5
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_simulator.py::test_run_simulation_returns_distribution -v`
Expected: FAIL with "cannot import name 'PriceSimulator'"

**Step 3: Write minimal implementation**

Add to `osrs_flipper/simulator.py`:

```python
import statistics
from typing import Dict, Any


class PriceSimulator:
    """Monte Carlo price simulator with optional mean reversion."""

    def __init__(
        self,
        historical_prices: List[int],
        mean_reversion_strength: float = 0.0,
    ):
        """Initialize simulator.

        Args:
            historical_prices: List of historical prices.
            mean_reversion_strength: Daily drift toward mean (0.02 = 2% pull per day).
        """
        self.prices = historical_prices
        self.returns = calculate_daily_returns(historical_prices)
        self.mean_reversion = mean_reversion_strength

        if historical_prices:
            self.historical_mean = statistics.mean(historical_prices)
        else:
            self.historical_mean = 0

    def run(
        self,
        num_sims: int = 10000,
        days: int = 30,
        start_price: int = None,
    ) -> Dict[str, Any]:
        """Run Monte Carlo simulation.

        Args:
            num_sims: Number of simulation paths.
            days: Days to simulate forward.
            start_price: Starting price (default: last historical price).

        Returns:
            Dict with prob_profit, prob_loss, percentiles, etc.
        """
        if start_price is None:
            start_price = self.prices[-1] if self.prices else 0

        if not self.returns or start_price <= 0:
            return {
                "prob_profit": 0.0,
                "prob_loss": 0.0,
                "percentiles": {},
                "final_prices": [],
            }

        final_prices = []

        for _ in range(num_sims):
            price = float(start_price)

            for _ in range(days):
                # Bootstrap a random historical return
                base_return = random.choice(self.returns)

                # Add mean reversion component
                if self.mean_reversion > 0 and price > 0:
                    # Pull toward historical mean
                    reversion = self.mean_reversion * (self.historical_mean - price) / price
                    daily_return = base_return + reversion
                else:
                    daily_return = base_return

                price = price * (1 + daily_return)
                price = max(1, price)  # Floor at 1 GP

            final_prices.append(int(round(price)))

        final_prices.sort()

        # Calculate statistics
        num_profit = sum(1 for p in final_prices if p > start_price)
        num_loss = sum(1 for p in final_prices if p < start_price)

        def percentile(pct: int) -> int:
            idx = int((pct / 100) * (len(final_prices) - 1))
            return final_prices[idx]

        return {
            "start_price": start_price,
            "prob_profit": num_profit / num_sims,
            "prob_loss": num_loss / num_sims,
            "expected_value": int(statistics.mean(final_prices)),
            "percentiles": {
                5: percentile(5),
                25: percentile(25),
                50: percentile(50),
                75: percentile(75),
                95: percentile(95),
            },
            "final_prices": final_prices,
        }
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_simulator.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/simulator.py tests/test_simulator.py
git commit -m "feat(simulator): add PriceSimulator with mean reversion"
```

---

## Task 4: Kelly Criterion Calculator

**Files:**
- Modify: `osrs_flipper/simulator.py`
- Modify: `tests/test_simulator.py`

**Step 1: Write the failing test**

Add to `tests/test_simulator.py`:

```python
def test_kelly_criterion_positive_edge():
    """Kelly should recommend bet size for positive expected value."""
    from osrs_flipper.simulator import calculate_kelly_fraction

    # 60% win rate, 1:1 odds (win = +100%, lose = -100%)
    kelly = calculate_kelly_fraction(
        prob_win=0.6,
        win_pct=1.0,  # 100% gain on win
        loss_pct=1.0,  # 100% loss on loss
    )

    # Kelly = p - q/b = 0.6 - 0.4/1 = 0.2 (20% of bankroll)
    assert abs(kelly - 0.2) < 0.01


def test_kelly_criterion_negative_edge():
    """Kelly should return 0 for negative expected value."""
    from osrs_flipper.simulator import calculate_kelly_fraction

    # 40% win rate - negative EV
    kelly = calculate_kelly_fraction(
        prob_win=0.4,
        win_pct=1.0,
        loss_pct=1.0,
    )

    assert kelly == 0.0
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_simulator.py::test_kelly_criterion_positive_edge -v`
Expected: FAIL with "cannot import name 'calculate_kelly_fraction'"

**Step 3: Write minimal implementation**

Add to `osrs_flipper/simulator.py`:

```python
def calculate_kelly_fraction(
    prob_win: float,
    win_pct: float,
    loss_pct: float,
) -> float:
    """Calculate Kelly Criterion optimal bet fraction.

    Args:
        prob_win: Probability of winning (0-1).
        win_pct: Percentage gain on win (0.5 = 50%).
        loss_pct: Percentage loss on loss (0.5 = 50%).

    Returns:
        Optimal fraction of bankroll to bet (0-1), 0 if negative EV.
    """
    if loss_pct <= 0 or win_pct <= 0:
        return 0.0

    prob_lose = 1 - prob_win

    # Kelly formula: f* = p/a - q/b
    # where p = prob win, q = prob lose, a = loss ratio, b = win ratio
    b = win_pct / loss_pct  # odds ratio

    kelly = prob_win - (prob_lose / b)

    # Never recommend betting if negative EV
    return max(0.0, kelly)
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_simulator.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/simulator.py tests/test_simulator.py
git commit -m "feat(simulator): add Kelly Criterion calculator"
```

---

## Task 5: Deep Analysis Method

**Files:**
- Modify: `osrs_flipper/simulator.py`
- Modify: `tests/test_simulator.py`

**Step 1: Write the failing test**

Add to `tests/test_simulator.py`:

```python
def test_deep_analysis_complete_output():
    """Deep analysis should return comprehensive item analysis."""
    random.seed(42)

    from osrs_flipper.simulator import PriceSimulator

    prices = [1000, 1050, 980, 1100, 950, 1080, 920, 1150, 900, 1200]
    current_price = 900  # At the low end
    daily_volume = 500
    buy_limit = 100

    sim = PriceSimulator(prices, mean_reversion_strength=0.01)
    result = sim.deep_analysis(
        current_price=current_price,
        daily_volume=daily_volume,
        buy_limit=buy_limit,
        days=30,
        num_sims=1000,
    )

    # Core simulation results
    assert "prob_profit" in result
    assert "prob_loss" in result
    assert "percentiles" in result

    # ROI calculations
    assert "roi_percentiles" in result
    assert 5 in result["roi_percentiles"]
    assert 50 in result["roi_percentiles"]
    assert 95 in result["roi_percentiles"]

    # Kelly sizing
    assert "kelly_fraction" in result
    assert 0 <= result["kelly_fraction"] <= 1

    # Liquidity analysis
    assert "days_to_fill" in result
    assert "liquidity_grade" in result
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_simulator.py::test_deep_analysis_complete_output -v`
Expected: FAIL with "AttributeError: 'PriceSimulator' object has no attribute 'deep_analysis'"

**Step 3: Write minimal implementation**

Add method to `PriceSimulator` class in `osrs_flipper/simulator.py`:

```python
    def deep_analysis(
        self,
        current_price: int,
        daily_volume: int,
        buy_limit: int,
        days: int = 30,
        num_sims: int = 10000,
    ) -> Dict[str, Any]:
        """Run comprehensive deep analysis on an item.

        Args:
            current_price: Current item price.
            daily_volume: Average daily volume traded.
            buy_limit: GE buy limit.
            days: Simulation horizon in days.
            num_sims: Number of Monte Carlo paths.

        Returns:
            Comprehensive analysis dict.
        """
        # Run base simulation
        sim_result = self.run(num_sims=num_sims, days=days, start_price=current_price)

        # Calculate ROI percentiles
        roi_percentiles = {}
        for pct, price in sim_result["percentiles"].items():
            roi = ((price - current_price) / current_price) * 100
            roi_percentiles[pct] = round(roi, 1)

        # Calculate Kelly fraction
        prob_profit = sim_result["prob_profit"]
        median_outcome = sim_result["percentiles"][50]

        if median_outcome > current_price:
            win_pct = (median_outcome - current_price) / current_price
        else:
            win_pct = 0.01  # Minimal win

        # Use 5th percentile as worst-case loss
        worst_case = sim_result["percentiles"][5]
        loss_pct = max(0.01, (current_price - worst_case) / current_price)

        kelly = calculate_kelly_fraction(prob_profit, win_pct, loss_pct)

        # Liquidity analysis
        if daily_volume > 0:
            days_to_fill = buy_limit / (daily_volume * 0.5)  # Assume 50% market share
        else:
            days_to_fill = float("inf")

        # Grade liquidity A-F
        if days_to_fill <= 1:
            liquidity_grade = "A"
        elif days_to_fill <= 3:
            liquidity_grade = "B"
        elif days_to_fill <= 7:
            liquidity_grade = "C"
        elif days_to_fill <= 14:
            liquidity_grade = "D"
        else:
            liquidity_grade = "F"

        return {
            **sim_result,
            "roi_percentiles": roi_percentiles,
            "kelly_fraction": round(kelly, 3),
            "days_to_fill": round(days_to_fill, 1),
            "liquidity_grade": liquidity_grade,
            "days_simulated": days,
            "num_sims": num_sims,
        }
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_simulator.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/simulator.py tests/test_simulator.py
git commit -m "feat(simulator): add deep_analysis method with Kelly and liquidity"
```

---

## Task 6: Deep CLI Command

**Files:**
- Modify: `osrs_flipper/cli.py`
- Modify: `tests/test_cli.py`

**Step 1: Write the failing test**

Add to `tests/test_cli.py`:

```python
def test_deep_command_exists():
    """Deep command should be registered."""
    from click.testing import CliRunner
    from osrs_flipper.cli import main

    runner = CliRunner()
    result = runner.invoke(main, ["deep", "--help"])

    assert result.exit_code == 0
    assert "Deep analysis" in result.output or "Monte Carlo" in result.output
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_cli.py::test_deep_command_exists -v`
Expected: FAIL with "No such command 'deep'"

**Step 3: Write minimal implementation**

Add to `osrs_flipper/cli.py` after imports:

```python
from .simulator import PriceSimulator
```

Add the deep command:

```python
@main.command()
@click.argument("item_name")
@click.option(
    "--days",
    type=int,
    default=30,
    help="Simulation horizon in days (default: 30)",
)
@click.option(
    "--sims",
    type=int,
    default=10000,
    help="Number of simulations (default: 10000)",
)
def deep(item_name, days, sims):
    """Deep analysis with Monte Carlo simulation for a specific item."""
    click.echo(f"Deep Analysis: {item_name}")
    click.echo("=" * 70)

    client = OSRSClient()

    # Find item by name
    click.echo("Fetching item data...")
    mapping = client.fetch_mapping()
    latest = client.fetch_latest()
    volumes = client.fetch_volumes()

    # Search for item (case-insensitive partial match)
    item_id = None
    item_info = None
    search_lower = item_name.lower()

    for iid, info in mapping.items():
        if info.get("name", "").lower() == search_lower:
            item_id = iid
            item_info = info
            break

    if not item_id:
        # Try partial match
        for iid, info in mapping.items():
            if search_lower in info.get("name", "").lower():
                item_id = iid
                item_info = info
                break

    if not item_id:
        click.echo(f"Item not found: {item_name}")
        return

    click.echo(f"Found: {item_info['name']} (ID: {item_id})")

    # Get price data
    price_data = latest.get(str(item_id), {})
    if not price_data:
        click.echo("No price data available.")
        return

    current_price = (price_data.get("high", 0) + price_data.get("low", 0)) // 2

    vol_data = volumes.get(str(item_id), {})
    instabuy_vol = vol_data.get("highPriceVolume", 0) or 0
    instasell_vol = vol_data.get("lowPriceVolume", 0) or 0
    daily_volume = instabuy_vol + instasell_vol
    buy_limit = item_info.get("limit", 1)

    # Fetch historical data
    click.echo("Fetching historical prices...")
    history = client.fetch_timeseries(item_id)

    if len(history) < 30:
        click.echo("Insufficient historical data (need 30+ days).")
        return

    prices = []
    for point in history:
        h = point.get("avgHighPrice")
        l = point.get("avgLowPrice")
        if h and l:
            prices.append((h + l) // 2)

    six_month_low = min(prices)
    six_month_high = max(prices)

    # Run simulation
    click.echo(f"Running {sims:,} simulations over {days} days...")

    sim = PriceSimulator(prices, mean_reversion_strength=0.01)
    result = sim.deep_analysis(
        current_price=current_price,
        daily_volume=daily_volume,
        buy_limit=buy_limit,
        days=days,
        num_sims=sims,
    )

    # Display results
    click.echo()
    click.echo(f"Current: {current_price:,} GP  |  6-mo range: {six_month_low:,} - {six_month_high:,}  |  Buy limit: {buy_limit:,}")
    click.echo()

    click.echo(f"Price Simulations ({sims:,} runs, {days}-day horizon):")
    click.echo(f"  P(profit):     {result['prob_profit']*100:.1f}%")
    click.echo(f"  P(loss):       {result['prob_loss']*100:.1f}%")
    click.echo()

    click.echo("  Expected outcomes:")
    for pct in [5, 25, 50, 75, 95]:
        price = result["percentiles"][pct]
        roi = result["roi_percentiles"][pct]
        label = ""
        if pct == 5:
            label = " <- worst realistic"
        elif pct == 50:
            label = " <- median"
        elif pct == 95:
            label = " <- best realistic"

        sign = "+" if roi >= 0 else ""
        click.echo(f"    {pct:>3}th %ile:  {sign}{roi:.1f}% ({price:,} GP){label}")

    click.echo()
    click.echo(f"  Kelly Criterion:  {result['kelly_fraction']*100:.1f}% of bankroll")
    click.echo()

    click.echo("Volume Analysis:")
    if daily_volume > 0:
        momentum = instabuy_vol / instasell_vol if instasell_vol > 0 else 99.9
        mom_arrow = "↑↑" if momentum >= 1.5 else "↑" if momentum >= 1.0 else "→" if momentum >= 0.7 else "↓"
        click.echo(f"  Daily volume:     {daily_volume:,}")
        click.echo(f"  Buyer momentum:   {mom_arrow} {momentum:.2f}x")
        click.echo(f"  Days to fill:     {result['days_to_fill']:.1f}")
        click.echo(f"  Liquidity grade:  {result['liquidity_grade']}")
    else:
        click.echo("  No volume data available")
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_cli.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/cli.py tests/test_cli.py
git commit -m "feat(cli): add deep command for Monte Carlo analysis"
```

---

## Task 7: Portfolio Optimizer Class

**Files:**
- Modify: `osrs_flipper/simulator.py`
- Modify: `tests/test_simulator.py`

**Step 1: Write the failing test**

Add to `tests/test_simulator.py`:

```python
def test_portfolio_optimizer_finds_best_allocation():
    """Optimizer should find allocation that maximizes expected value."""
    random.seed(42)

    from osrs_flipper.simulator import PortfolioOptimizer

    # Create mock items with different risk/reward profiles
    items = [
        {
            "name": "Safe Item",
            "current_price": 1000,
            "prices": [1000, 1010, 1005, 1015, 1008, 1020],  # Low volatility
            "daily_volume": 10000,
            "buy_limit": 1000,
        },
        {
            "name": "Risky Item",
            "current_price": 500,
            "prices": [1000, 800, 600, 400, 500, 300, 700, 500],  # High volatility
            "daily_volume": 500,
            "buy_limit": 100,
        },
        {
            "name": "Recovery Item",
            "current_price": 200,
            "prices": [500, 450, 400, 350, 300, 250, 200],  # Crashed, may recover
            "daily_volume": 2000,
            "buy_limit": 500,
        },
    ]

    optimizer = PortfolioOptimizer(items)
    result = optimizer.optimize(
        total_cash=1000000,
        slots=3,
        num_sims=500,
        days=30,
    )

    assert "allocations" in result
    assert "expected_portfolio_value" in result
    assert "portfolio_prob_profit" in result
    assert len(result["allocations"]) <= 3


def test_portfolio_optimizer_respects_cash_limit():
    """Optimizer should not exceed cash limit."""
    random.seed(42)

    from osrs_flipper.simulator import PortfolioOptimizer

    items = [
        {
            "name": "Expensive Item",
            "current_price": 1000000,
            "prices": [1000000, 1100000, 900000, 1050000],
            "daily_volume": 10,
            "buy_limit": 5,
        },
    ]

    optimizer = PortfolioOptimizer(items)
    result = optimizer.optimize(
        total_cash=500000,  # Can't afford even 1
        slots=8,
        num_sims=100,
        days=30,
    )

    total_allocated = sum(a.get("capital", 0) for a in result["allocations"])
    assert total_allocated <= 500000
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_simulator.py::test_portfolio_optimizer_finds_best_allocation -v`
Expected: FAIL with "cannot import name 'PortfolioOptimizer'"

**Step 3: Write minimal implementation**

Add to `osrs_flipper/simulator.py`:

```python
class PortfolioOptimizer:
    """Optimize portfolio allocation using Monte Carlo simulation."""

    def __init__(self, items: List[Dict[str, Any]]):
        """Initialize optimizer with candidate items.

        Args:
            items: List of item dicts with name, current_price, prices,
                   daily_volume, buy_limit.
        """
        self.items = items

    def optimize(
        self,
        total_cash: int,
        slots: int,
        num_sims: int = 5000,
        days: int = 30,
    ) -> Dict[str, Any]:
        """Find optimal portfolio allocation.

        Args:
            total_cash: Total GP to allocate.
            slots: Number of GE slots available.
            num_sims: Simulations per item.
            days: Simulation horizon.

        Returns:
            Dict with allocations and portfolio metrics.
        """
        # Score each item
        scored_items = []

        for item in self.items:
            prices = item.get("prices", [])
            if len(prices) < 10:
                continue

            sim = PriceSimulator(prices, mean_reversion_strength=0.01)
            analysis = sim.deep_analysis(
                current_price=item["current_price"],
                daily_volume=item.get("daily_volume", 0),
                buy_limit=item.get("buy_limit", 1),
                days=days,
                num_sims=num_sims,
            )

            # Score = expected ROI * probability of profit * liquidity factor
            median_roi = analysis["roi_percentiles"].get(50, 0)
            prob_profit = analysis["prob_profit"]

            # Liquidity penalty
            liq_factor = {"A": 1.0, "B": 0.9, "C": 0.7, "D": 0.5, "F": 0.2}
            liq = liq_factor.get(analysis["liquidity_grade"], 0.5)

            score = median_roi * prob_profit * liq

            scored_items.append({
                **item,
                "analysis": analysis,
                "score": score,
            })

        # Sort by score
        scored_items.sort(key=lambda x: x["score"], reverse=True)

        # Greedy allocation to top items
        allocations = []
        remaining_cash = total_cash

        for item in scored_items[:slots]:
            if remaining_cash <= 0:
                break

            price = item["current_price"]
            buy_limit = item.get("buy_limit", 1)

            # Fair share of remaining cash
            slots_remaining = slots - len(allocations)
            fair_share = remaining_cash // max(slots_remaining, 1)

            # Max by buy limit (assume 3 rotations)
            max_by_limit = buy_limit * 3 * price

            # Actual allocation
            slot_capital = min(fair_share, max_by_limit, remaining_cash)
            quantity = slot_capital // price if price > 0 else 0

            if quantity > 0:
                actual_capital = quantity * price
                analysis = item["analysis"]

                allocations.append({
                    "name": item["name"],
                    "current_price": price,
                    "quantity": quantity,
                    "capital": actual_capital,
                    "prob_profit": analysis["prob_profit"],
                    "median_roi": analysis["roi_percentiles"].get(50, 0),
                    "kelly_fraction": analysis["kelly_fraction"],
                    "score": item["score"],
                })

                remaining_cash -= actual_capital

        # Calculate portfolio-level metrics
        if allocations:
            total_capital = sum(a["capital"] for a in allocations)
            weighted_prob = sum(
                a["prob_profit"] * a["capital"] for a in allocations
            ) / total_capital
            weighted_roi = sum(
                a["median_roi"] * a["capital"] for a in allocations
            ) / total_capital
            expected_value = int(total_capital * (1 + weighted_roi / 100))
        else:
            total_capital = 0
            weighted_prob = 0
            weighted_roi = 0
            expected_value = 0

        return {
            "allocations": allocations,
            "total_capital": total_capital,
            "cash_remaining": remaining_cash,
            "portfolio_prob_profit": weighted_prob,
            "portfolio_median_roi": weighted_roi,
            "expected_portfolio_value": expected_value,
        }
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_simulator.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/simulator.py tests/test_simulator.py
git commit -m "feat(simulator): add PortfolioOptimizer for multi-item optimization"
```

---

## Task 8: Portfolio Optimize CLI Command

**Files:**
- Modify: `osrs_flipper/cli.py`
- Modify: `tests/test_cli.py`

**Step 1: Write the failing test**

Add to `tests/test_cli.py`:

```python
def test_portfolio_optimize_option_exists():
    """Portfolio command should have --optimize flag."""
    from click.testing import CliRunner
    from osrs_flipper.cli import main

    runner = CliRunner()
    result = runner.invoke(main, ["portfolio", "--help"])

    assert result.exit_code == 0
    assert "--optimize" in result.output
```

**Step 2: Run test to verify it fails**

Run: `python3 -m pytest tests/test_cli.py::test_portfolio_optimize_option_exists -v`
Expected: FAIL (--optimize not in output)

**Step 3: Write minimal implementation**

Modify the portfolio command in `osrs_flipper/cli.py`:

Add import at top:
```python
from .simulator import PriceSimulator, PortfolioOptimizer
```

Add option to portfolio command:
```python
@click.option(
    "--optimize",
    is_flag=True,
    help="Run Monte Carlo optimization to find best allocation",
)
@click.option(
    "--sims",
    type=int,
    default=1000,
    help="Simulations per item for optimization (default: 1000)",
)
```

Update function signature:
```python
def portfolio(ctx, list_presets, use, recommend, cash, slots, save, optimize, sims):
```

Add optimization logic before the final else:
```python
    if optimize:
        if not cash:
            raise click.UsageError("--cash required with --optimize")

        cash_gp = parse_cash(cash)
        click.echo(f"Portfolio Optimizer - Monte Carlo Mode")
        click.echo("=" * 70)
        click.echo(f"Cash: {cash_gp:,} GP | Slots: {slots} | Sims: {sims:,}")
        click.echo()

        client = OSRSClient()
        scanner = ItemScanner(client)

        click.echo("Scanning for opportunities...")
        opportunities = scanner.scan(mode="all")

        if not opportunities:
            click.echo("No opportunities found.")
            return

        click.echo(f"Found {len(opportunities)} candidates. Running simulations...")

        # Prepare items for optimizer
        items = []
        for opp in opportunities:
            # We need historical prices - fetch them
            try:
                history = client.fetch_timeseries(opp["item_id"])
                prices = []
                for point in history:
                    h = point.get("avgHighPrice")
                    l = point.get("avgLowPrice")
                    if h and l:
                        prices.append((h + l) // 2)

                if len(prices) >= 30:
                    items.append({
                        "name": opp["name"],
                        "item_id": opp["item_id"],
                        "current_price": opp["current_price"],
                        "prices": prices,
                        "daily_volume": opp["daily_volume"],
                        "buy_limit": opp.get("buy_limit", 1),
                    })
            except Exception:
                continue

        if not items:
            click.echo("No items with sufficient data for optimization.")
            return

        click.echo(f"Optimizing {len(items)} items...")

        optimizer = PortfolioOptimizer(items)
        result = optimizer.optimize(
            total_cash=cash_gp,
            slots=slots,
            num_sims=sims,
            days=30,
        )

        # Display optimized portfolio
        click.echo()
        click.echo(f"{'Slot':<4} {'Item':<22} {'Capital':>12} {'P(profit)':>10} {'Med ROI':>8} {'Kelly':>7}")
        click.echo("-" * 75)

        for i, alloc in enumerate(result["allocations"], 1):
            click.echo(
                f"{i:<4} "
                f"{alloc['name'][:21]:<22} "
                f"{alloc['capital']:>12,} "
                f"{alloc['prob_profit']*100:>9.1f}% "
                f"{alloc['median_roi']:>7.1f}% "
                f"{alloc['kelly_fraction']*100:>6.1f}%"
            )

        click.echo("-" * 75)
        click.echo(f"{'Total Invested:':<30} {result['total_capital']:>12,} GP")
        click.echo(f"{'Cash Remaining:':<30} {result['cash_remaining']:>12,} GP")
        click.echo(f"{'Portfolio P(profit):':<30} {result['portfolio_prob_profit']*100:>11.1f}%")
        click.echo(f"{'Portfolio Median ROI:':<30} {result['portfolio_median_roi']:>11.1f}%")
        click.echo(f"{'Expected Value ({sims} sims):':<30} {result['expected_portfolio_value']:>12,} GP")
        return
```

**Step 4: Run test to verify it passes**

Run: `python3 -m pytest tests/test_cli.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add osrs_flipper/cli.py tests/test_cli.py
git commit -m "feat(cli): add --optimize flag to portfolio command"
```

---

## Task 9: Final Integration Test

**Files:**
- Run all tests

**Step 1: Run full test suite**

Run: `python3 -m pytest tests/ -v`
Expected: All tests PASS

**Step 2: Manual CLI test**

Run: `python3 -m osrs_flipper.cli deep "Abyssal whip" --sims 1000`
Expected: Full deep analysis output

Run: `python3 -m osrs_flipper.cli portfolio --optimize --cash 100m --slots 6 --sims 500`
Expected: Optimized portfolio allocation

**Step 3: Final commit**

```bash
git add -A
git commit -m "feat: complete Monte Carlo simulation system

- Daily returns calculator with bootstrap resampling
- Price path generator with mean reversion
- Monte Carlo simulator with probability distributions
- Kelly Criterion for optimal bet sizing
- Deep analysis command for single-item research
- Portfolio optimizer for multi-item allocation
- All tests passing"
```

---

**Plan complete and saved to `docs/plans/2025-12-09-monte-carlo-simulation.md`. Two execution options:**

**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

**Which approach?**
